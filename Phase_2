PHASE_2 // Fibonacci sequence is such that each number is the sum of the two preceding ones starting from 0 and 1.
lab-2@lab2-OptiPlex-3040:~/Desktop/Bomb/Assignment 1_2(1)/Assignment 1/bomb003$ gdb bomb
GNU gdb (Ubuntu 9.2-0ubuntu1~20.04) 9.2
Copyright (C) 2020 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.
Type "show copying" and "show warranty" for details.
This GDB was configured as "x86_64-linux-gnu".
Type "show configuration" for configuration details.
For bug reporting instructions, please see:
<http://www.gnu.org/software/gdb/bugs/>.
Find the GDB manual and other documentation resources online at:
    <http://www.gnu.org/software/gdb/documentation/>.

For help, type "help".
Type "apropos word" to search for commands related to "word"...
Reading symbols from bomb...
(gdb) b phase_2 // put breakpoint in phase_2 
Breakpoint 1 at 0x400ea9
(gdb) r sol.txt // save the answer in sol.tex
Starting program: /home/lab-2/Desktop/Bomb/Assignment 1_2(1)/Assignment 1/bomb003/bomb sol.txt
Welcome to my fiendish little bomb. You have 6 phases with
which to blow yourself up. Have a nice day!
Phase 1 defused. How about the next one?
1 2 3 4 5 6 // user test input or random 6 digit number 

Breakpoint 1, 0x0000000000400ea9 in phase_2 ()
(gdb) disas
Dump of assembler code for function phase_2:
=> 0x0000000000400ea9 <+0>:	push   %rbp
   0x0000000000400eaa <+1>:	push   %rbx
   0x0000000000400eab <+2>:	sub    $0x28,%rsp
   0x0000000000400eaf <+6>:	mov    %fs:0x28,%rax
   0x0000000000400eb8 <+15>:	mov    %rax,0x18(%rsp)
   0x0000000000400ebd <+20>:	xor    %eax,%eax
   0x0000000000400ebf <+22>:	mov    %rsp,%rsi
   0x0000000000400ec2 <+25>:	callq  0x40144c <read_six_numbers> // we have to take six degit number
   0x0000000000400ec7 <+30>:	cmpl   $0x0,(%rsp) // we have to compare the integer with value stored in the register %rsp
   0x0000000000400ecb <+34>:	jne    0x400ed4 <phase_2+43> // if the value stored is equal than it will jump to next line if not it will explode in line number 43.
   0x0000000000400ecd <+36>:	cmpl   $0x1,0x4(%rsp) // again it will compare the value stored in register address
   0x0000000000400ed2 <+41>:	je     0x400ed9 <phase_2+48> // jump if only equals to if not bomb will explode in line 48
   0x0000000000400ed4 <+43>:	callq  0x40142a <explode_bomb>
   0x0000000000400ed9 <+48>:	mov    %rsp,%rbx
   0x0000000000400edc <+51>:	lea    0x10(%rsp),%rbp
   0x0000000000400ee1 <+56>:	mov    0x4(%rbx),%eax
   0x0000000000400ee4 <+59>:	add    (%rbx),%eax
   0x0000000000400ee6 <+61>:	cmp    %eax,0x8(%rbx)
   0x0000000000400ee9 <+64>:	je     0x400ef0 <phase_2+71>
   0x0000000000400eeb <+66>:	callq  0x40142a <explode_bomb>
   0x0000000000400ef0 <+71>:	add    $0x4,%rbx
   0x0000000000400ef4 <+75>:	cmp    %rbp,%rbx
--Type <RET> for more, q to quit, c to continue without paging--
   0x0000000000400ef7 <+78>:	jne    0x400ee1 <phase_2+56>
   0x0000000000400ef9 <+80>:	mov    0x18(%rsp),%rax
   0x0000000000400efe <+85>:	xor    %fs:0x28,%rax
   0x0000000000400f07 <+94>:	je     0x400f0e <phase_2+101>
   0x0000000000400f09 <+96>:	callq  0x400b00 <__stack_chk_fail@plt>
   0x0000000000400f0e <+101>:	add    $0x28,%rsp
   0x0000000000400f12 <+105>:	pop    %rbx
   0x0000000000400f13 <+106>:	pop    %rbp
   0x0000000000400f14 <+107>:	retq   
End of assembler dump.
(gdb) r sol.txt
The program being debugged has been started already.
Start it from the beginning? (y or n) y
Starting program: /home/lab-2/Desktop/Bomb/Assignment 1_2(1)/Assignment 1/bomb003/bomb sol.txt
Welcome to my fiendish little bomb. You have 6 phases with
which to blow yourself up. Have a nice day!
Phase 1 defused. How about the next one?
1 2 3 4 5 6  // since we know that we have to take the input of 6 random degit

Breakpoint 1, 0x0000000000400ea9 in phase_2 ()
(gdb) disas
Dump of assembler code for function phase_2:
=> 0x0000000000400ea9 <+0>:	push   %rbp
   0x0000000000400eaa <+1>:	push   %rbx
   0x0000000000400eab <+2>:	sub    $0x28,%rsp
   0x0000000000400eaf <+6>:	mov    %fs:0x28,%rax
   0x0000000000400eb8 <+15>:	mov    %rax,0x18(%rsp)
   0x0000000000400ebd <+20>:	xor    %eax,%eax
   0x0000000000400ebf <+22>:	mov    %rsp,%rsi
   0x0000000000400ec2 <+25>:	callq  0x40144c <read_six_numbers>
   0x0000000000400ec7 <+30>:	cmpl   $0x0,(%rsp)
   0x0000000000400ecb <+34>:	jne    0x400ed4 <phase_2+43>
   0x0000000000400ecd <+36>:	cmpl   $0x1,0x4(%rsp)
   0x0000000000400ed2 <+41>:	je     0x400ed9 <phase_2+48>
   0x0000000000400ed4 <+43>:	callq  0x40142a <explode_bomb>
   0x0000000000400ed9 <+48>:	mov    %rsp,%rbx
   0x0000000000400edc <+51>:	lea    0x10(%rsp),%rbp
   0x0000000000400ee1 <+56>:	mov    0x4(%rbx),%eax
   0x0000000000400ee4 <+59>:	add    (%rbx),%eax
   0x0000000000400ee6 <+61>:	cmp    %eax,0x8(%rbx)
   0x0000000000400ee9 <+64>:	je     0x400ef0 <phase_2+71>
   0x0000000000400eeb <+66>:	callq  0x40142a <explode_bomb>
   0x0000000000400ef0 <+71>:	add    $0x4,%rbx
   0x0000000000400ef4 <+75>:	cmp    %rbp,%rbx
--Type <RET> for more, q to quit, c to continue without paging--
   0x0000000000400ef7 <+78>:	jne    0x400ee1 <phase_2+56>
   0x0000000000400ef9 <+80>:	mov    0x18(%rsp),%rax
   0x0000000000400efe <+85>:	xor    %fs:0x28,%rax
   0x0000000000400f07 <+94>:	je     0x400f0e <phase_2+101>
   0x0000000000400f09 <+96>:	callq  0x400b00 <__stack_chk_fail@plt>
   0x0000000000400f0e <+101>:	add    $0x28,%rsp
   0x0000000000400f12 <+105>:	pop    %rbx
   0x0000000000400f13 <+106>:	pop    %rbp
   0x0000000000400f14 <+107>:	retq   
End of assembler dump.
(gdb) u * 0x0000000000400ec7 // to know the information stored in register compare $0x1,0x4(%rsp):
0x0000000000400ec7 in phase_2 ()
(gdb) disas
Dump of assembler code for function phase_2:
   0x0000000000400ea9 <+0>:	push   %rbp
   0x0000000000400eaa <+1>:	push   %rbx
   0x0000000000400eab <+2>:	sub    $0x28,%rsp
   0x0000000000400eaf <+6>:	mov    %fs:0x28,%rax
   0x0000000000400eb8 <+15>:	mov    %rax,0x18(%rsp)
   0x0000000000400ebd <+20>:	xor    %eax,%eax
   0x0000000000400ebf <+22>:	mov    %rsp,%rsi
   0x0000000000400ec2 <+25>:	callq  0x40144c <read_six_numbers>
=> 0x0000000000400ec7 <+30>:	cmpl   $0x0,(%rsp) // compare the first degit to the value in (%rsp) which was the first user input (1 2 3 4 5 6)
   0x0000000000400ecb <+34>:	jne    0x400ed4 <phase_2+43> // jump if it is not equal to or it will explode the bomb.
   0x0000000000400ecd <+36>:	cmpl   $0x1,0x4(%rsp) // compare the second degit to the value in (4+%rsp) 
   0x0000000000400ed2 <+41>:	je     0x400ed9 <phase_2+48> // jump if equal to if not it will explode in line 48
   0x0000000000400ed4 <+43>:	callq  0x40142a <explode_bomb>
   0x0000000000400ed9 <+48>:	mov    %rsp,%rbx
   0x0000000000400edc <+51>:	lea    0x10(%rsp),%rbp
   0x0000000000400ee1 <+56>:	mov    0x4(%rbx),%eax
   0x0000000000400ee4 <+59>:	add    (%rbx),%eax
   0x0000000000400ee6 <+61>:	cmp    %eax,0x8(%rbx) //it compares if the added values in %eax is equal to the user input or not
   0x0000000000400ee9 <+64>:	je     0x400ef0 <phase_2+71>
   0x0000000000400eeb <+66>:	callq  0x40142a <explode_bomb>
   0x0000000000400ef0 <+71>:	add    $0x4,%rbx
   0x0000000000400ef4 <+75>:	cmp    %rbp,%rbx
--Type <RET> for more, q to quit, c to continue without paging--
   0x0000000000400ef7 <+78>:	jne    0x400ee1 <phase_2+56>
   0x0000000000400ef9 <+80>:	mov    0x18(%rsp),%rax
   0x0000000000400efe <+85>:	xor    %fs:0x28,%rax
   0x0000000000400f07 <+94>:	je     0x400f0e <phase_2+101>
   0x0000000000400f09 <+96>:	callq  0x400b00 <__stack_chk_fail@plt>
   0x0000000000400f0e <+101>:	add    $0x28,%rsp
   0x0000000000400f12 <+105>:	pop    %rbx
   0x0000000000400f13 <+106>:	pop    %rbp
   0x0000000000400f14 <+107>:	retq   
End of assembler dump.
(gdb) i r // information registre to know about the register
rax            0x6                 6
rbx            0x7fffffffdf28      140737488346920
rcx            0x0                 0
rdx            0x7fffffffde04      140737488346628
rsi            0x0                 0
rdi            0x7fffffffd780      140737488344960
rbp            0x0                 0x0
rsp            0x7fffffffddf0      0x7fffffffddf0
r8             0xffffffff          4294967295
r9             0x0                 0
r10            0x7ffff7f61ac0      140737353489088
r11            0x0                 0
r12            0x400c60            4197472
r13            0x7fffffffdf20      140737488346912
r14            0x0                 0
r15            0x0                 0
rip            0x400ec7            0x400ec7 <phase_2+30>
eflags         0x206               [ PF IF ]
cs             0x33                51
ss             0x2b                43
ds             0x0                 0
es             0x0                 0
fs             0x0                 0
--Type <RET> for more, q to quit, c to continue without paging--
gs             0x0                 0
(gdb) x/d 0x7fffffffddf0  
0x7fffffffddf0:	1 
(gdb) r sol.txt
The program being debugged has been started already.
Start it from the beginning? (y or n) y
Starting program: /home/lab-2/Desktop/Bomb/Assignment 1_2(1)/Assignment 1/bomb003/bomb sol.txt
Welcome to my fiendish little bomb. You have 6 phases with
which to blow yourself up. Have a nice day!
Phase 1 defused. How about the next one?
0 2 3 4 5 6 // from the above comparision we know that first degit is 0

Breakpoint 1, 0x0000000000400ea9 in phase_2 ()
(gdb) disas
Dump of assembler code for function phase_2:
=> 0x0000000000400ea9 <+0>:	push   %rbp
   0x0000000000400eaa <+1>:	push   %rbx
   0x0000000000400eab <+2>:	sub    $0x28,%rsp
   0x0000000000400eaf <+6>:	mov    %fs:0x28,%rax
   0x0000000000400eb8 <+15>:	mov    %rax,0x18(%rsp)
   0x0000000000400ebd <+20>:	xor    %eax,%eax
   0x0000000000400ebf <+22>:	mov    %rsp,%rsi
   0x0000000000400ec2 <+25>:	callq  0x40144c <read_six_numbers>
   0x0000000000400ec7 <+30>:	cmpl   $0x0,(%rsp)
   0x0000000000400ecb <+34>:	jne    0x400ed4 <phase_2+43>
   0x0000000000400ecd <+36>:	cmpl   $0x1,0x4(%rsp)
   0x0000000000400ed2 <+41>:	je     0x400ed9 <phase_2+48>
   0x0000000000400ed4 <+43>:	callq  0x40142a <explode_bomb>
   0x0000000000400ed9 <+48>:	mov    %rsp,%rbx
   0x0000000000400edc <+51>:	lea    0x10(%rsp),%rbp
   0x0000000000400ee1 <+56>:	mov    0x4(%rbx),%eax
   0x0000000000400ee4 <+59>:	add    (%rbx),%eax
   0x0000000000400ee6 <+61>:	cmp    %eax,0x8(%rbx)
   0x0000000000400ee9 <+64>:	je     0x400ef0 <phase_2+71>
   0x0000000000400eeb <+66>:	callq  0x40142a <explode_bomb>
   0x0000000000400ef0 <+71>:	add    $0x4,%rbx
   0x0000000000400ef4 <+75>:	cmp    %rbp,%rbx
--Type <RET> for more, q to quit, c to continue without paging--
   0x0000000000400ef7 <+78>:	jne    0x400ee1 <phase_2+56>
   0x0000000000400ef9 <+80>:	mov    0x18(%rsp),%rax
   0x0000000000400efe <+85>:	xor    %fs:0x28,%rax
   0x0000000000400f07 <+94>:	je     0x400f0e <phase_2+101>
   0x0000000000400f09 <+96>:	callq  0x400b00 <__stack_chk_fail@plt>
   0x0000000000400f0e <+101>:	add    $0x28,%rsp
   0x0000000000400f12 <+105>:	pop    %rbx
   0x0000000000400f13 <+106>:	pop    %rbp
   0x0000000000400f14 <+107>:	retq   
End of assembler dump.
(gdb) ni
0x0000000000400eaa in phase_2 ()
(gdb) disas
Dump of assembler code for function phase_2:
   0x0000000000400ea9 <+0>:	push   %rbp
=> 0x0000000000400eaa <+1>:	push   %rbx
   0x0000000000400eab <+2>:	sub    $0x28,%rsp
   0x0000000000400eaf <+6>:	mov    %fs:0x28,%rax
   0x0000000000400eb8 <+15>:	mov    %rax,0x18(%rsp)
   0x0000000000400ebd <+20>:	xor    %eax,%eax
   0x0000000000400ebf <+22>:	mov    %rsp,%rsi
   0x0000000000400ec2 <+25>:	callq  0x40144c <read_six_numbers>
   0x0000000000400ec7 <+30>:	cmpl   $0x0,(%rsp)
   0x0000000000400ecb <+34>:	jne    0x400ed4 <phase_2+43>
   0x0000000000400ecd <+36>:	cmpl   $0x1,0x4(%rsp)
   0x0000000000400ed2 <+41>:	je     0x400ed9 <phase_2+48>
   0x0000000000400ed4 <+43>:	callq  0x40142a <explode_bomb>
   0x0000000000400ed9 <+48>:	mov    %rsp,%rbx
   0x0000000000400edc <+51>:	lea    0x10(%rsp),%rbp
   0x0000000000400ee1 <+56>:	mov    0x4(%rbx),%eax
   0x0000000000400ee4 <+59>:	add    (%rbx),%eax
   0x0000000000400ee6 <+61>:	cmp    %eax,0x8(%rbx)
   0x0000000000400ee9 <+64>:	je     0x400ef0 <phase_2+71>
   0x0000000000400eeb <+66>:	callq  0x40142a <explode_bomb>
   0x0000000000400ef0 <+71>:	add    $0x4,%rbx
   0x0000000000400ef4 <+75>:	cmp    %rbp,%rbx
--Type <RET> for more, q to quit, c to continue without paging--
   0x0000000000400ef7 <+78>:	jne    0x400ee1 <phase_2+56>
   0x0000000000400ef9 <+80>:	mov    0x18(%rsp),%rax
   0x0000000000400efe <+85>:	xor    %fs:0x28,%rax
   0x0000000000400f07 <+94>:	je     0x400f0e <phase_2+101>
   0x0000000000400f09 <+96>:	callq  0x400b00 <__stack_chk_fail@plt>
   0x0000000000400f0e <+101>:	add    $0x28,%rsp
   0x0000000000400f12 <+105>:	pop    %rbx
   0x0000000000400f13 <+106>:	pop    %rbp
   0x0000000000400f14 <+107>:	retq   
End of assembler dump.
(gdb) u * 0x0000000000400ecd
0x0000000000400ecd in phase_2 ()
(gdb) disas
Dump of assembler code for function phase_2:
   0x0000000000400ea9 <+0>:	push   %rbp
   0x0000000000400eaa <+1>:	push   %rbx
   0x0000000000400eab <+2>:	sub    $0x28,%rsp
   0x0000000000400eaf <+6>:	mov    %fs:0x28,%rax
   0x0000000000400eb8 <+15>:	mov    %rax,0x18(%rsp)
   0x0000000000400ebd <+20>:	xor    %eax,%eax
   0x0000000000400ebf <+22>:	mov    %rsp,%rsi
   0x0000000000400ec2 <+25>:	callq  0x40144c <read_six_numbers>
   0x0000000000400ec7 <+30>:	cmpl   $0x0,(%rsp)
   0x0000000000400ecb <+34>:	jne    0x400ed4 <phase_2+43>
=> 0x0000000000400ecd <+36>:	cmpl   $0x1,0x4(%rsp)
   0x0000000000400ed2 <+41>:	je     0x400ed9 <phase_2+48>
   0x0000000000400ed4 <+43>:	callq  0x40142a <explode_bomb>
   0x0000000000400ed9 <+48>:	mov    %rsp,%rbx
   0x0000000000400edc <+51>:	lea    0x10(%rsp),%rbp
   0x0000000000400ee1 <+56>:	mov    0x4(%rbx),%eax
   0x0000000000400ee4 <+59>:	add    (%rbx),%eax
   0x0000000000400ee6 <+61>:	cmp    %eax,0x8(%rbx)
   0x0000000000400ee9 <+64>:	je     0x400ef0 <phase_2+71>
   0x0000000000400eeb <+66>:	callq  0x40142a <explode_bomb>
   0x0000000000400ef0 <+71>:	add    $0x4,%rbx
   0x0000000000400ef4 <+75>:	cmp    %rbp,%rbx
--Type <RET> for more, q to quit, c to continue without paging--
   0x0000000000400ef7 <+78>:	jne    0x400ee1 <phase_2+56>
   0x0000000000400ef9 <+80>:	mov    0x18(%rsp),%rax
   0x0000000000400efe <+85>:	xor    %fs:0x28,%rax
   0x0000000000400f07 <+94>:	je     0x400f0e <phase_2+101>
   0x0000000000400f09 <+96>:	callq  0x400b00 <__stack_chk_fail@plt>
   0x0000000000400f0e <+101>:	add    $0x28,%rsp
   0x0000000000400f12 <+105>:	pop    %rbx
   0x0000000000400f13 <+106>:	pop    %rbp
   0x0000000000400f14 <+107>:	retq   
End of assembler dump.
(gdb) i r
rax            0x6                 6
rbx            0x7fffffffdf28      140737488346920
rcx            0x0                 0
rdx            0x7fffffffde04      140737488346628
rsi            0x0                 0
rdi            0x7fffffffd780      140737488344960
rbp            0x0                 0x0
rsp            0x7fffffffddf0      0x7fffffffddf0
r8             0xffffffff          4294967295
r9             0x0                 0
r10            0x7ffff7f61ac0      140737353489088
r11            0x0                 0
r12            0x400c60            4197472
r13            0x7fffffffdf20      140737488346912
r14            0x0                 0
r15            0x0                 0
rip            0x400ecd            0x400ecd <phase_2+36>
eflags         0x246               [ PF ZF IF ]
cs             0x33                51
ss             0x2b                43
ds             0x0                 0
es             0x0                 0
fs             0x0                 0
--Type <RET> for more, q to quit, c to continue without paging--
gs             0x0                 0
(gdb) x/2 0x7fffffffddf0 
0x7fffffffddf0:	0	2
(gdb) r sol.txt
The program being debugged has been started already.
Start it from the beginning? (y or n) y
Starting program: /home/lab-2/Desktop/Bomb/Assignment 1_2(1)/Assignment 1/bomb003/bomb sol.txt
Welcome to my fiendish little bomb. You have 6 phases with
which to blow yourself up. Have a nice day!
Phase 1 defused. How about the next one?
0 1 3 4 5 6 // we know that second degit is 1

Breakpoint 1, 0x0000000000400ea9 in phase_2 ()
(gdb) disas
Dump of assembler code for function phase_2:
=> 0x0000000000400ea9 <+0>:	push   %rbp
   0x0000000000400eaa <+1>:	push   %rbx
   0x0000000000400eab <+2>:	sub    $0x28,%rsp
   0x0000000000400eaf <+6>:	mov    %fs:0x28,%rax
   0x0000000000400eb8 <+15>:	mov    %rax,0x18(%rsp)
   0x0000000000400ebd <+20>:	xor    %eax,%eax
   0x0000000000400ebf <+22>:	mov    %rsp,%rsi
   0x0000000000400ec2 <+25>:	callq  0x40144c <read_six_numbers>
   0x0000000000400ec7 <+30>:	cmpl   $0x0,(%rsp)
   0x0000000000400ecb <+34>:	jne    0x400ed4 <phase_2+43>
   0x0000000000400ecd <+36>:	cmpl   $0x1,0x4(%rsp)
   0x0000000000400ed2 <+41>:	je     0x400ed9 <phase_2+48>
   0x0000000000400ed4 <+43>:	callq  0x40142a <explode_bomb>
   0x0000000000400ed9 <+48>:	mov    %rsp,%rbx
   0x0000000000400edc <+51>:	lea    0x10(%rsp),%rbp
   0x0000000000400ee1 <+56>:	mov    0x4(%rbx),%eax
   0x0000000000400ee4 <+59>:	add    (%rbx),%eax
   0x0000000000400ee6 <+61>:	cmp    %eax,0x8(%rbx)
   0x0000000000400ee9 <+64>:	je     0x400ef0 <phase_2+71>
   0x0000000000400eeb <+66>:	callq  0x40142a <explode_bomb>
   0x0000000000400ef0 <+71>:	add    $0x4,%rbx
   0x0000000000400ef4 <+75>:	cmp    %rbp,%rbx
--Type <RET> for more, q to quit, c to continue without paging--
   0x0000000000400ef7 <+78>:	jne    0x400ee1 <phase_2+56>
   0x0000000000400ef9 <+80>:	mov    0x18(%rsp),%rax
   0x0000000000400efe <+85>:	xor    %fs:0x28,%rax
   0x0000000000400f07 <+94>:	je     0x400f0e <phase_2+101>
   0x0000000000400f09 <+96>:	callq  0x400b00 <__stack_chk_fail@plt>
   0x0000000000400f0e <+101>:	add    $0x28,%rsp
   0x0000000000400f12 <+105>:	pop    %rbx
   0x0000000000400f13 <+106>:	pop    %rbp
   0x0000000000400f14 <+107>:	retq   
End of assembler dump.
(gdb) u * 0x0000000000400ee6
0x0000000000400ee6 in phase_2 ()
(gdb) disas
Dump of assembler code for function phase_2:
   0x0000000000400ea9 <+0>:	push   %rbp
   0x0000000000400eaa <+1>:	push   %rbx
   0x0000000000400eab <+2>:	sub    $0x28,%rsp
   0x0000000000400eaf <+6>:	mov    %fs:0x28,%rax
   0x0000000000400eb8 <+15>:	mov    %rax,0x18(%rsp)
   0x0000000000400ebd <+20>:	xor    %eax,%eax
   0x0000000000400ebf <+22>:	mov    %rsp,%rsi
   0x0000000000400ec2 <+25>:	callq  0x40144c <read_six_numbers>
   0x0000000000400ec7 <+30>:	cmpl   $0x0,(%rsp)
   0x0000000000400ecb <+34>:	jne    0x400ed4 <phase_2+43>
   0x0000000000400ecd <+36>:	cmpl   $0x1,0x4(%rsp)
   0x0000000000400ed2 <+41>:	je     0x400ed9 <phase_2+48>
   0x0000000000400ed4 <+43>:	callq  0x40142a <explode_bomb>
   0x0000000000400ed9 <+48>:	mov    %rsp,%rbx
   0x0000000000400edc <+51>:	lea    0x10(%rsp),%rbp
   0x0000000000400ee1 <+56>:	mov    0x4(%rbx),%eax
   0x0000000000400ee4 <+59>:	add    (%rbx),%eax
=> 0x0000000000400ee6 <+61>:	cmp    %eax,0x8(%rbx)
   0x0000000000400ee9 <+64>:	je     0x400ef0 <phase_2+71>
   0x0000000000400eeb <+66>:	callq  0x40142a <explode_bomb>
   0x0000000000400ef0 <+71>:	add    $0x4,%rbx
   0x0000000000400ef4 <+75>:	cmp    %rbp,%rbx
--Type <RET> for more, q to quit, c to continue without paging--
   0x0000000000400ef7 <+78>:	jne    0x400ee1 <phase_2+56>
   0x0000000000400ef9 <+80>:	mov    0x18(%rsp),%rax
   0x0000000000400efe <+85>:	xor    %fs:0x28,%rax
   0x0000000000400f07 <+94>:	je     0x400f0e <phase_2+101>
   0x0000000000400f09 <+96>:	callq  0x400b00 <__stack_chk_fail@plt>
   0x0000000000400f0e <+101>:	add    $0x28,%rsp
   0x0000000000400f12 <+105>:	pop    %rbx
   0x0000000000400f13 <+106>:	pop    %rbp
   0x0000000000400f14 <+107>:	retq   
End of assembler dump.
(gdb) i r
rax            0x1                 1
rbx            0x7fffffffddf0      140737488346608
rcx            0x0                 0
rdx            0x7fffffffde04      140737488346628
rsi            0x0                 0
rdi            0x7fffffffd780      140737488344960
rbp            0x7fffffffde00      0x7fffffffde00
rsp            0x7fffffffddf0      0x7fffffffddf0
r8             0xffffffff          4294967295
r9             0x0                 0
r10            0x7ffff7f61ac0      140737353489088
r11            0x0                 0
r12            0x400c60            4197472
r13            0x7fffffffdf20      140737488346912
r14            0x0                 0
r15            0x0                 0
rip            0x400ee6            0x400ee6 <phase_2+61>
eflags         0x202               [ IF ]
cs             0x33                51
ss             0x2b                43
ds             0x0                 0
es             0x0                 0
fs             0x0                 0
--Type <RET> for more, q to quit, c to continue without paging--
gs             0x0                 0
(gdb) x/3d0x7fffffffddf0 
0x7fffffffddf0:	0	1	3 // we know that thired degit is not 3
(gdb) r sol.txt
The program being debugged has been started already.
Start it from the beginning? (y or n) y
Starting program: /home/lab-2/Desktop/Bomb/Assignment 1_2(1)/Assignment 1/bomb003/bomb sol.txt
Welcome to my fiendish little bomb. You have 6 phases with
which to blow yourself up. Have a nice day!
Phase 1 defused. How about the next one?
0 1 1 2 3 5 // from the hint we got from above the order of fibonacci series is proved.

Breakpoint 1, 0x0000000000400ea9 in phase_2 ()
(gdb) d
Delete all breakpoints? (y or n) y
(gdb) r sol.txt
The program being debugged has been started already.
Start it from the beginning? (y or n) y
Starting program: /home/lab-2/Desktop/Bomb/Assignment 1_2(1)/Assignment 1/bomb003/bomb sol.txt
Welcome to my fiendish little bomb. You have 6 phases with
which to blow yourself up. Have a nice day!
Phase 1 defused. How about the next one?
0 1 1 2 3 5 // this is a final solution of the phase_2
That's number 2.  Keep going!







